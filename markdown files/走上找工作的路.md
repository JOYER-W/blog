# 走上找工作的路

## **iOS内存管理**

在Objective-C中有两套内存管理策略，MRC(Mannul Reference Counting)和ARC(Automatic Referenct Counting)，但是两套都是基于引用计数来进行内存管理的。
	
MRC遵循着谁创建谁释放，一般会有如下情况，创建一个新对象的方法：`new`,`alloc`,`copy`,`mutableCopy`,此时的引用计数都是retain count都是为1，此时当进行了如下操作，新对象会获取原来对象的所有权，引用计数就会增加，`id newObj = [oldObj retain]`, 所以，针对如上的操作都需要手动调用`release`。如下，`[newObj release]`.  
	
ARC是自iOS5之后推出的新的内存管理策略，一种自动引用计数技术。其管理内存的策略和MRC一致，仅仅只是编译器在特定的位置帮我们加上`release`代码。
> Automatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects. Rather than having to think about retain and release operations, ARC allows you to concentrate on the interesting code.

本人也是从iOS7开始接触iOS开发的。所以一直以来都是使用ARC内存管理规则。
> ARC works by adding code at compile time to ensure that objects live as long as necessary, but no longer.

ARC的解释是在编译时，编译器会在对象的生命周期中添加必要的代码(`release`代码)。即，现在不需要我们手动的调用`release`

* **iOS 中可能的内存泄漏**
	* 循环引用  
		只要是使用了的是引用计数策略进行内存管理的，就会有出现循环引用的可能性，导致内存无法释放掉而内存泄漏。
		1. 对象间的循环引用	，使用弱引用来破解。如下，分别有objA，objB，objC，三个对象，属性间相互引用，造成了循环引用。此时可以设置对象objC指向对象objA的属性为弱引用类型。
		
				objA.property = objB;
				objB.property = objC;
				objC.property = objA;
		
			
		2. 对象和Block之间的循环引用
				
				self.someBlock = ^{ self.property = xxx; };
			如上出现了循环引用，此时编译器可以检测出，直接会报错。但是当有其他对象介入的时候时候，编译器就不能在编译期发现是否出现了循环引用。  
				
				someObj.someBlock = ^{ self.property = xxx;};
				self.someObj = someObj;
			
			* **解决方案**
			
			使用`__weak`修饰，弱化block中对象引用。如下
			
				__weak SomeObjectClass *weakSelf = self;
				someObj.someBlock = ^{
					SomeObjectClass *strongSelf = weakSelf;
					if (strongSelf == nil) {
						// handle 
					}
					[strongSelf sendMsg];
				};
		
		3. 	NSTimer 
			
			在OC中有很多的`Action/Target`的模式，大多数的情况下都是弱引用了`target`，但是在NSTimer中并不是这样的，`timer`对象强引用了`target`
			
				+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds
                        					target:(id)target
					                      selector:(SEL)aSelector
                      					  userInfo:(id)userInfo
                       					   repeats:(BOOL)repeats
			> 解释target : The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated.

## **UITableView的优化**

	
## **UDP和TCP**
	
TCP和UDP是计算机网络中学习到的概念，它们两者都属于运输层。  
	
TCP(Transmission Control Protocol)是一种**面相连接，可靠的流协议**，其中连接的意思指的是两个应用为了通信，在两者之间建立的一种虚拟的线路。可靠的流协议指的是不间断数据结构，就比如管道中的水流，TCP提供了如重发机制，流量控制等一系列的可靠性保障。虽然有TCP有很多优点，也有不足的地方，就是传输效率比较低。	
	
UDP(User Datagram Protocol)是一种**不具有可靠性的数据报协议**，只负责发送信息，但是不确定对方是否收到。但是优点就是效率非常高。
	
使用场景：场景都是基于其优缺点。由于TCP传输可靠性很强，所以在传输文件，收发邮件等。UDP效率高，可靠性比较低，一般用于网络电话，视频，语音等，必须是实时的，其中可能有一点点断断续续，可能影响不会很大。

## **SDWebImage的原理** 

## **什么时候会造成内存泄漏**

## **自动释放池的原理**

## **nonatomic和atomic**
 